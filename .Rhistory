Overwrite == TRUE) {
#Create an Indicator to Determine if an Overwrite is Performed
if (file.exists(here("df_with_County_Groups.csv")) == TRUE &
Overwrite == TRUE) {
Overwrite_Necessary <- TRUE
} else {
Overwrite_Necessary <- FALSE
}
#Write the Analytic_Data to a .csv File
write.csv(
Analytic_Data,
file = here("df_with_County_Groups.csv"),
row.names = FALSE
)
#Print a Message Describing the Operation Outcome
if (Overwrite_Necessary == FALSE) {
print("Saved Analytic_Data as df_with_County_Groups.csv")
} else {
print("Overwrote df_with_County_Groups.csv")
}
} else {
print("File Exists and Overwrite = FALSE, Operation Suspended")
}
table(Analytic_Data$County.FIPS.Group *
Analytic_Data$County.FIPS)
table(Analytic_Data$County.FIPS.Group,
Analytic_Data$County.FIPS)
table(Analytic_Data$County.FIPS)
table(Analytic_Data$County.FIPS,
Analytic_Data$County.FIPS.Group)
#Import the Analytic Data
Analytic_Data <-
read.csv(here("df.csv"))
#Set a Seed for Reproducibility
set.seed(15)
#Randomly Order all of the County FIPS and Place in Data Frame
Groups_Data <-
data.frame(sample(
unique(Analytic_Data$County.FIPS),
length(unique(Analytic_Data$County.FIPS)),
replace = FALSE
))
#Assign Group to County FIPS based on the Row Number
for (i in 1:nrow(Groups_Data)) {
if (i <= round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 1"
} else
if (i <= 2 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 2"
} else
if (i <= 3 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 3"
} else
if (i <= 4 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 4"
} else
if (i <= 5 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 5"
} else
if (i <= 6 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 6"
} else
if (i <= 7 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 7"
} else
if (i <= 8 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 8"
} else
if (i <= 9 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group 9"
} else
{
Groups_Data[i, 2] <- "Group 10"
}
}
#Set Column Names
colnames(Groups_Data) <- c("County.FIPS", "County.FIPS.Group")
#Check the Number of Group Assignments
table(Groups_Data[, 2])
#Create New Column in Analytic Data
Analytic_Data$County.FIPS.Group <- NA
#Add Assignments to Analytic Data
for (i in 1:nrow(Analytic_Data)) {
for (j in 1:nrow(Groups_Data)) {
if (Analytic_Data$County.FIPS[i] == Groups_Data$County.FIPS[j]) {
Analytic_Data$County.FIPS.Group[i] = Groups_Data$County.FIPS.Group[j]
}
}
#Progress Tracker
if ((i / 100) == round(i / 100)) {
#Clear Console
cat("\014")
#Print Percent Complete
print(paste(round((
i / nrow(Analytic_Data) * 100
), 4), "% Complete", sep = ""))
}
#Completion Indicator
if (i == nrow(Analytic_Data)) {
#Clear Console
cat("\014")
#Print Done
print("100% Complete - Done!")
}
}
#Show Data Summary Indicating County FIPS Assignment and the Number of Entries
#for each County
table(Analytic_Data$County.FIPS,
Analytic_Data$County.FIPS.Group)
#Show Data Summary Indicating County FIPS Assignment and the Number of Entries
#for each County
table(Analytic_Data$County.FIPS,
Analytic_Data$County.FIPS.Group)
#Check the Number of Observations in each Group
table(Analytic_Data$County.FIPS.Group)
#Overwrite Indicator
Overwrite <- TRUE
#Export Data
if (file.exists(here("df_with_County_Groups.csv")) == FALSE |
Overwrite == TRUE) {
#Create an Indicator to Determine if an Overwrite is Performed
if (file.exists(here("df_with_County_Groups.csv")) == TRUE &
Overwrite == TRUE) {
Overwrite_Necessary <- TRUE
} else {
Overwrite_Necessary <- FALSE
}
#Write the Analytic_Data to a .csv File
write.csv(
Analytic_Data,
file = here("df_with_County_Groups.csv"),
row.names = FALSE
)
#Print a Message Describing the Operation Outcome
if (Overwrite_Necessary == FALSE) {
print("Saved Analytic_Data as df_with_County_Groups.csv")
} else {
print("Overwrote df_with_County_Groups.csv")
}
} else {
print("File Exists and Overwrite = FALSE, Data Export Halted")
}
View(Analytic_Data)
Working_Data <- Analytic_Data[, c(7, 9:25, 43)]
View(Working_Data)
Training <- Working_Data[Working_Data$County.FIPS.Group == "Group 1",
-19]
View(Training)
Test <- Working_Data[Working_Data$County.FIPS.Group == "Group 1", -19]
Training <- Working_Data[Working_Data$County.FIPS.Group != "Group 1", -19]
Model <- train(Mortality ~ .,
data = Training,
method = "knn",
preProcess = c("center", "scale"))
#Subset the Needed Columns from the Analytic Data to Perform KNN Regression
Working_Data <- Analytic_Data[, c(7, 9:25, 43)]
#Subset the Test Set
Test <-
Working_Data[Working_Data$County.FIPS.Group == "Group 1",-19]
#Subset the Training Set
Training <-
Working_Data[Working_Data$County.FIPS.Group != "Group 1",-19]
#Perform the KNN Regression
Model <- train(
Mortality ~ .,
data = Training,
method = "knn",
preProcess = c("center", "scale"))
Test_Features <- subset(Model, select = -c(Mortality))
Test_Features <- subset(Model, select = -c(Mortality))
Test_Features <- subset(Test, select = -c(Mortality))
View(Test)
View(Test_Features)
Test_Target <- subset(Target, select = Mortality)[, 1]
Test_Target <- subset(Test, select = Mortality)[, 1]
Test_Features <- subset(Test, select = -c(Mortality))
Test_Target <- subset(Test, select = Mortality)[, 1]
Predictions <- predict(Model, newdata = Test_Features)
sqrt(mean((Test_Target - Predictions) ^ 2))
summary(Model)
mean((Test_Target - Predictions) ^ 2)
cor(Test_Target, Predictions) ^ 2
Model
Test_Features <- subset(Test, select = -c(Mortality))
Test_Target <- subset(Test, select = Mortality)[, 1]
Predictions <- predict(Model, newdata = Test_Features)
Predictions <- predict(Model, newdata = Test_Features)
mean((Test_Target - Predictions) ^ 2)
mean((Test_Target - Predictions) ^ 2)
cor(Test_Target, Predictions) ^ 2
>>>>>>> Stashed changes
knitr::opts_chunk$set(echo = TRUE)
#Load the Needed Libraries
library(tidyverse)
library(here)
library(caret)
#Clear the Environment
rm(list = ls())
#Ensure Directory is Set Properly
if(file.exists(paste(getwd(), "/.here", sep = "")) == FALSE) {
#Create the .here file
set_here()
#Reboot R
.rs.restartR()
}
#Clear the Console
cat("\014")
#Check to Determine if this Process has already been Completed
if (file.exists(here("df_with_County_Groups.csv")) == FALSE) {
#Import the Analytic Data
Analytic_Data <-
read.csv(here("df.csv"))
#Set a Seed for Reproducibility
set.seed(15)
#Randomly Order all of the County FIPS and Place in Data Frame
Groups_Data <-
data.frame(sample(
unique(Analytic_Data$County.FIPS),
length(unique(Analytic_Data$County.FIPS)),
replace = FALSE
))
#Assign Group to County FIPS based on the Row Number
for (i in 1:nrow(Groups_Data)) {
if (i <= round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_01"
} else
if (i <= 2 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_02"
} else
if (i <= 3 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_03"
} else
if (i <= 4 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_04"
} else
if (i <= 5 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_05"
} else
if (i <= 6 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_06"
} else
if (i <= 7 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_07"
} else
if (i <= 8 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_08"
} else
if (i <= 9 * round(nrow(Groups_Data) / 10)) {
Groups_Data[i, 2] <- "Group_09"
} else
{
Groups_Data[i, 2] <- "Group_10"
}
}
#Set Column Names
colnames(Groups_Data) <- c("County.FIPS", "County.FIPS.Group")
#Check the Number of Group Assignments
table(Groups_Data[, 2])
#Create New Column in Analytic Data
Analytic_Data$County.FIPS.Group <- NA
#Add Assignments to Analytic Data
for (i in 1:nrow(Analytic_Data)) {
for (j in 1:nrow(Groups_Data)) {
if (Analytic_Data$County.FIPS[i] == Groups_Data$County.FIPS[j]) {
Analytic_Data$County.FIPS.Group[i] = Groups_Data$County.FIPS.Group[j]
}
}
#Progress Tracker
if ((i / 100) == round(i / 100)) {
#Clear Console
cat("\014")
#Print Percent Complete
print(paste(round((
i / nrow(Analytic_Data) * 100
), 4), "% Complete", sep = ""))
}
#Completion Indicator
if (i == nrow(Analytic_Data)) {
#Clear Console
cat("\014")
#Print Done
print("100% Complete - Done!")
}
}
} else {
Analytic_Data <- read.csv(here("df_with_County_Groups.csv"))
print("Downloaded Analytic Data with County Groups from Git Hub")
}
#Show Data Summary Indicating County FIPS Assignment and the Number of Entries
#for each County
table(Analytic_Data$County.FIPS,
Analytic_Data$County.FIPS.Group)
#Check the Number of Observations in each Group
table(Analytic_Data$County.FIPS.Group)
#Overwrite Indicator
Overwrite <- FALSE
#Export Data
if (file.exists(here("df_with_County_Groups.csv")) == FALSE |
Overwrite == TRUE) {
#Create an Indicator to Determine if an Overwrite is Performed
if (file.exists(here("df_with_County_Groups.csv")) == TRUE &
Overwrite == TRUE) {
Overwrite_Necessary <- TRUE
} else {
Overwrite_Necessary <- FALSE
}
#Write the Analytic_Data to a .csv File
write.csv(
Analytic_Data,
file = here("df_with_County_Groups.csv"),
row.names = FALSE
)
#Print a Message Describing the Operation Outcome
if (Overwrite_Necessary == FALSE) {
print("Saved Analytic_Data as df_with_County_Groups.csv")
} else {
print("Overwrote df_with_County_Groups.csv")
}
} else {
print("File Exists and Overwrite = FALSE, Data Export Halted")
}
#Subset the Needed Columns from the Analytic Data to Perform KNN Regression
Working_Data <- Analytic_Data[, c(7, 9:25, 43)]
#Create a List of the Groups
Groups <-
unique(Analytic_Data$County.FIPS.Group)[
order(unique(Analytic_Data$County.FIPS.Group))]
#Create Directory for Model Predictions if Needed
if (dir.exists(here("KNN_Model_Predictions")) == FALSE) {
dir.create(here("KNN_Model_Predictions"))
}
#Cycle All Groups
for (i in 1:length(Groups)) {
#Create Directory to Store Results if Needed
if (dir.exists(here("KNN_Model_Predictions", Groups[i])) == FALSE) {
dir.create(here("KNN_Model_Predictions", Groups[i]))
}
#Set the Group ID
Group <- Groups[i]
if (file.exists(here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Output_", Group, ".txt", sep = ""))) == FALSE) {
#Subset the Test Set, Features, and Response Values
Test <-
Working_Data[Working_Data$County.FIPS.Group == Group, -19]
Test_Features <- subset(Test, select = -c(Mortality))
Test_Response <- subset(Test, select = Mortality)[, 1]
#Subset the Training Set
Training <-
Working_Data[Working_Data$County.FIPS.Group != Group, -19]
#Perform the KNN Regression
Model <- train(
Mortality ~ .,
data = Training,
method = "knn",
preProcess = c("center", "scale"))
#Set the Working Directory
setwd(here("KNN_Model_Predictions", Groups[i]))
#Call the Sink Function for the Model Output
sink(file = paste("Model_Output_", Group, ".txt", sep = ""))
#Print the Model Output
print(Model)
#End the Sink Function
sink()
#Call the PDF Function
pdf(file = paste("Model_Plot_", Group, ".pdf", sep = ""))
#Plot the Model Output
print(plot(Model))
#End the PDF Function
dev.off()
#Calculate Predictions for Test Set
Test$Group <- Group
Test$Predictions <- predict(Model, newdata = Test_Features)
#Save the Test Set
write.csv(
Test,
file = here(
"KNN_Model_Predictions",
Groups[i],
paste("Test_Data_and_Predictions_", Group, ".csv", sep = "")),
row.names = FALSE)
#Add Group to the Training Data
Training$Group <- Group
#Save the Training Set
write.csv(
Training,
file = here(
"KNN_Model_Predictions",
Groups[i],
paste("Training_Data_", Group, ".csv", sep = "")),
row.names = FALSE)
#Calculate Model Fit Metrics
Metrics <- data.frame(Group = Group,
MSE = mean((Test_Response - Test$Predictions) ^ 2),
R_Squared = cor(Test_Response, Test$Predictions) ^ 2)
#Save the Metrics
write.csv(
Metrics,
file = here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Metrics_", Group, ".csv", sep = "")),
row.names = FALSE)
#Reset the Working Directory
setwd(here())
#Create Model Metrics Summary if it Doesn't Exist
if (exists("Model_Metrics") == FALSE) {
Model_Metrics <-
read_csv(here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Metrics_", Group, ".csv", sep = "")))
} else {
#Row Bind New Model Metrics in if Model Metrics Exists
Model_Metrics <- rbind(Model_Metrics, read_csv(here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Metrics_", Group, ".csv", sep = ""))))
}
} else {
#If the Model Results alredy Exist
#Create Model Metrics Summary in R if it Doesn't Exist
if (exists("Model_Metrics") == FALSE) {
Model_Metrics <-
read_csv(here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Metrics_", Group, ".csv", sep = "")))
} else {
#Row Bind New Model Metrics in if Model Metrics Exists in R
Model_Metrics <- rbind(Model_Metrics, read_csv(here(
"KNN_Model_Predictions",
Groups[i],
paste("Model_Metrics_", Group, ".csv", sep = ""))))
}
}
}
#Save the Metrics Summary
write.csv(
Model_Metrics,
file = here(
"KNN_Model_Predictions",
paste("Model_Metrics_Summary.csv", sep = "")),
row.names = FALSE)
#Create Directory for Model Plots
if (dir.exists(here("KNN_Model_Predictions", "Plots")) == FALSE) {
dir.create(here("KNN_Model_Predictions", "Plots"))
}
#Cycle All Groups
for (i in 1:length(Groups)) {
#Set the Group ID
Interest_Group <- Groups[i]
#Plot True and Predicted Values for Group_05
Plot_Data <- read_csv(
here(
"KNN_Model_Predictions",
Interest_Group,
paste("Test_Data_and_Predictions_", Interest_Group, ".csv",
sep = "")))
#Order the Data by Mortality
Plot_Data <- Plot_Data[order(Plot_Data$Mortality),]
#Create Column to Fill with Values
Plot_Data$Order <- NA
#Add Column of Row Names
for (i in 1:nrow(Plot_Data)) {
Plot_Data$Order[i] <- i
}
#Create Plot Showing Predictions with Real Values
print(
ggplot(data = Plot_Data,
aes(x = Order)) +
#Plot Predictions
geom_point(
aes(y = Predictions),
shape = 21,
color = "cornflowerblue",
size = 0.5) +
#Plot Real Values
geom_point(aes(y = Mortality),
size = 0.5) +
#Add Axis Labels
xlab("Subject") +
ylab("Mortality") +
#Add Title
labs(
title = paste(
"Plot of Observed and Predicted Mortality for ",
Interest_Group,
sep = ""),
subtitle = paste(
"MSE = ",
round(Model_Metrics$MSE[which(Model_Metrics$Group == Interest_Group)], 4),
"     R-Squared = ",
round(Model_Metrics$R_Squared[which(Model_Metrics$Group == Interest_Group)], 4),
sep = "")))
#Save the Plot
ggsave(
path = here("KNN_Model_Predictions", "Plots"),
filename = paste(
"Plot_of_Observed_and_Predicted_Mortality_for_",
Interest_Group,
".jpg",
sep = ""
)
)
}
View(Model_Metrics)
View(Analytic_Data)
mean(Model_Metrics$MSE)
mean(Model_Metrics$R_Squared)
?train

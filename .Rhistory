list[[i]]$Score <-list_scores[[i]][6][c(1,2),]
}
return(list)
}
#Application:
master_list <- names_ESPN(master_list, master_list_names_and_scores)
View(master_list)
master_list <- as.list(py$result_df)
master_list[3]
master_list[1]
reticulate::repl_python()
reticulate::repl_python()
#Home Games ==============================================================
# The directory of the text file with the ESPN links goes in the line below:
links = pd.read_csv(r"C:\Users\hadsa\OneDrive\Desktop\Football Project\Game_Links_Home.txt", names=['links'])
result_df = []
result_names = []
result_result = []
for _, link in links.links.items():
page = urlopen(link)
soup_obj = bs.BeautifulSoup(page, 'html.parser')
table = soup_obj.find_all('table')
df = pd.read_html(str(table))[1].transpose()
df.columns = df.iloc[0, :]
df = df.iloc[1:, :]
dfnames = pd.read_html(str(table))[0]
result_df.append(df)
result_names.append(dfnames)
# Note that due to ESPN's data formats, a temporary solution is to separate text
# files: one containing home games, and another containing away games.
master_list[3]
quit
master_list <- as.list(py$result_df)
master_list[3]
master_list_names_and_scores <- as.list(py$result_names)
master_list <- as.list(py$result_df)
master_list_names_and_scores <- as.list(py$result_names)
#Adding Names to master_list dataframes from the master_list_names_and_scores list.
#Function:
names_ESPN <- function(list, list_scores){
for(i in 1:length(list)){
#Row Names as Team Abbreviation:
rownames(list[[i]]) <- list_scores[[i]][c(1,2),1]
#Putting the final score in:
list[[i]]$Score <-list_scores[[i]][6][c(1,2),]
}
return(list)
}
#Application:
master_list <- names_ESPN(master_list, master_list_names_and_scores)
master_list[2]
master_list[3]
apply(master_list, print)
print(master_list)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reticulate)
library(stringr)
setwd("C:/Users/hadsa/OneDrive/Desktop/Football Project/GS_Football")
reticulate::repl_python()
import pandas as pd
import numpy as np
import matplotlib as plt
import sklearn as sk
import bs4 as bs
from urllib.request import urlopen
import html5lib
#Home Games ==============================================================
# The directory of the text file with the ESPN links goes in the line below:
links = pd.read_csv(r"C:\Users\hadsa\OneDrive\Desktop\Football Project\Game_Links_Home.txt", names=['links'])
result_df = []
result_names = []
result_result = []
for _, link in links.links.items():
page = urlopen(link)
soup_obj = bs.BeautifulSoup(page, 'html.parser')
table = soup_obj.find_all('table')
df = pd.read_html(str(table))[1].transpose()
df.columns = df.iloc[0, :]
df = df.iloc[1:, :]
dfnames = pd.read_html(str(table))[0]
result_df.append(df)
result_names.append(dfnames)
# Note that due to ESPN's data formats, a temporary solution is to separate text
# files: one containing home games, and another containing away games.
quit
master_list <- as.list(py$result_df)
master_list_names_and_scores <- as.list(py$result_names)
#Adding Names to master_list dataframes from the master_list_names_and_scores list.
#Function:
names_ESPN <- function(list, list_scores){
for(i in 1:length(list)){
#Row Names as Team Abbreviation:
rownames(list[[i]]) <- list_scores[[i]][c(1,2),1]
#Putting the final score in:
list[[i]]$Score <-list_scores[[i]][6][c(1,2),]
}
return(list)
}
#Application:
master_list <- names_ESPN(master_list, master_list_names_and_scores)
ratio_ESPN <- function(list){
col_position <- c(2,3,6)
for(i in 1:length(list)){
# Getting Total Passing Attempts:
list[[i]]$Pass_Att <- as.numeric(word(list[[i]][,6], start = 1, sep = "-"))
# Getting Total Penalty Yards
list[[i]]$Penalty_yrds <- as.numeric(word(list[[i]][,12], start = -1, sep = "-"))
# Renaming Comp-Att to "Completion Percentage".
colnames(list[[i]])[6] <- "Completion Percentage"
# Getting Proportions for variables: 3rd Down Eff, 4th Down Eff, Completion.
for(k in col_position){
if(as.numeric(word(list[[i]][1,k], start = 1, sep = "-")[1]) == 0){
list[[i]][1,k] <- 0
}else{
list[[i]][1,k] <- as.numeric(word(list[[i]][1,k], start = 1, sep = "-"))/
as.numeric(word(list[[i]][1,k], start = -1, sep = "-"))
}
if(as.numeric(as.numeric(word(list[[i]][1,k], start = 1, sep = "-"))[1]) == 0){
list[[i]][2,k] <- 0
}else{
list[[i]][2,k] <- as.numeric(word(list[[i]][2,k], start = 1, sep = "-"))/
as.numeric(word(list[[i]][2,k], start = -1, sep = "-"))
}
}
# Changing Time of Possession to a Numeric Variable (in minutes):
#Row 1
list[[i]][1, 16] <- as.numeric(word(list[[i]][1,16], start = 1, sep = ":"))+
(as.numeric(word(list[[i]][1,16], start = -1, sep = ":"))/60)
#Row 2
list[[i]][2, 16] <- as.numeric(word(list[[i]][2,16], start = 1, sep = ":"))+
(as.numeric(word(list[[i]][2,16], start = -1, sep = ":"))/60)
}
return(list)
}
master_list <- ratio_ESPN(master_list)
for(i in 1:length(master_list)){
master_list[[i]][,-12] <- as.numeric(unlist(master_list[[i]][,-12]))
}
for(i in 1:length(master_list)){
master_list[[i]][-12] <- round(master_list[[i]][-12], digits = 4)
}
master_list[2]
print(master_list)
library(ggcorrplot)
corrplot::corrplot(df[8:24])
corrplot::corrplot(df)
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
cor()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot()
cor() %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perrenisl Snow`,
OPN_SPC = `Prop Developed Open SPace`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perrenisl Snow`,
OPN_SPC = `Prop Developed Open SPace`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`)
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perrenial Snow`,
OPN_SPC = `Prop Developed Open SPace`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open SPace`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open Space`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot()
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open Space`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot(method = "square")
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open Space`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
princomp() %>%
plot()
pca_df_propvars <- df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open Space`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`)
princomp(pca_df_propvars)
df %>%
pivot_longer(cols = `Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
ggplot(aes(x = value)) +
geom_density() +
facet_wrap(~name, scales = "free")
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Prop Unclassified`,
OPN_WTR = `Prop Open Water`,
PRN_SNW = `Prop Perennial Snow`,
OPN_SPC = `Prop Developed Open Space`,
LOW_INT = `Prop Developed Low Intensity`,
MED_INT = `Prop Developed Medium Intensity`,
HIG_INT = `Prop Developed High Intensity`,
BRN_LND = `Prop Barren Land`,
DCD_FRT = `Prop Deciduous Forest`,
EVG_FRT = `Prop Evergreen Forest`,
MXD_FRT = `Prop Mixed Forest`,
SHB_SCB = `Prop Shrub/Scrub`,
HRB_LND = `Prop Herbaceous Land`,
HAY_PAS = `Prop Hay/Pasture`,
CTV_CRP = `Prop Cultivated Crops`,
WDY_WET = `Prop Woody Wetlands`,
EMG_HRB = `Prop Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot(method = "square")
var(pca_df_propvars)
ggplot(aes(x = sqrt_value)) +
geom_density() +
facet_wrap(~name, scales = "free")
df %>%
pivot_longer(cols = `Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
mutate(sqrt_value = sqrt(value)) %>%
ggplot(aes(x = sqrt_value)) +
geom_density() +
facet_wrap(~name, scales = "free")
df %>%
pivot_longer(cols = `Unclassified`:`Emergent Herbaceous Land`) %>%
ggplot(aes(x = value)) +
geom_density() +
facet_wrap(~name, scales = "free")
df %>%
select(`Prop Unclassified`:`Prop Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Unclassified`,
OPN_WTR = `Open Water`,
PRN_SNW = `Perennial Snow`,
OPN_SPC = `Developed Open Space`,
LOW_INT = `Developed Low Intensity`,
MED_INT = `Developed Medium Intensity`,
HIG_INT = `Developed High Intensity`,
BRN_LND = `Barren Land`,
DCD_FRT = `Deciduous Forest`,
EVG_FRT = `Evergreen Forest`,
MXD_FRT = `Mixed Forest`,
SHB_SCB = `Shrub/Scrub`,
HRB_LND = `Herbaceous Land`,
HAY_PAS = `Hay/Pasture`,
CTV_CRP = `Cultivated Crops`,
WDY_WET = `Woody Wetlands`,
EMG_HRB = `Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot(method = "square")
df %>%
select(`Unclassified`:`Emergent Herbaceous Land`) %>%
rename(UNCLASS = `Unclassified`,
OPN_WTR = `Open Water`,
PRN_SNW = `Perennial Snow`,
OPN_SPC = `Developed Open Space`,
LOW_INT = `Developed Low Intensity`,
MED_INT = `Developed Medium Intensity`,
HIG_INT = `Developed High Intensity`,
BRN_LND = `Barren Land`,
DCD_FRT = `Deciduous Forest`,
EVG_FRT = `Evergreen Forest`,
MXD_FRT = `Mixed Forest`,
SHB_SCB = `Shrub/Scrub`,
HRB_LND = `Herbaceous Land`,
HAY_PAS = `Hay/Pasture`,
CTV_CRP = `Cultivated Crops`,
WDY_WET = `Woody Wetlands`,
EMG_HRB = `Emergent Herbaceous Land`) %>%
cor() %>%
corrplot::corrplot(method = "square")
print(master_list)
return(list(loglik=loglik, U=sum(U), dU=sum(dU)))
#Pre-Functions + Packages
#=========================================
library(tidyverse)
#Expression for this Particular Likelihood:
f.exp_int <- function(z, Status, lambda){
n <- length(z)
loglik <- expression(-lambda*z+Status*log(exp(lambda*z)-1))
U <- -z+(Status*z*exp(lambda*z)/(exp(lambda*z)-1))
dU <- -(Status*(z^2)*exp(lambda*z))/(exp(lambda*z)-1)^2
return(list(loglik=loglik, U=sum(U), dU=sum(dU)))
}
#NR Function
NR_Estimate <- function(z, indicator, lambda_0,m){
tmp.iter <- NULL
for(l in 1:m){
one <- f.exp_int(z = z, Status = indicator, lambda = lambda_0)
tmp.iter <- rbind(tmp.iter, c(lambda = lambda_0, U = one$U, dU =one$dU))
lambda_0 <- lambda_0 - one$U/one$dU
}
return(list(sequence = tmp.iter, MLE = tmp.iter[nrow(tmp.iter)]))
}
#The Simulation
cens_sim <- function(k,n,mu_r,m){
MLE_Sample <- matrix(data = NA, nrow = k, ncol = 2)
for(j in 1:k){
for(i in 1:n){
ev_time <- NULL
censor <- NULL
ev_time <- rexp(n, rate = 5)
censor <- rexp(n, rate = mu_r)
}
#Right Censoring Data
z <- cbind(ev_time, censor)
z <- as.data.frame(z)
z <- z %>%
mutate(Status = ifelse(ev_time <= censor, 1, 0),
z = ifelse(ev_time <= censor, ev_time, censor)) %>%
select(z, Status)
#Interval Censoring Data
z2 <- cbind(ev_time, censor)
z2 <- as.data.frame(z2)
z2 <- z2 %>%
mutate(Status = ifelse(ev_time <= censor, 1, 0)) %>%
select(censor, Status)
colnames(z2) <- c("z", "Status")
MLE1 <- sum(z$Status)/sum(z$z)
MLE2 <- NR_Estimate(z2$z, indicator = z2$Status, lambda_0 =  5, m = m)$MLE
MLE_Sample[j,1] <- MLE1
MLE_Sample[j,2] <- MLE2
}
return(list(MLE_set = as.data.frame(MLE_Sample)))
}
#=========================================
#Getting Answers
#===========================================================
#Right Censored answer function
RC_give_answers <- function(mu_r){
bias <- NULL
st_d <- NULL
sizes <- c(100, 200, 400)
for(i in 1:3){
bias[i] <- mean(cens_sim(1000, n = sizes[i], mu_r = mu_r, m = 100)$MLE_set$V1, na.rm = TRUE) - 5
st_d[i] <- sd(cens_sim(1000, n = sizes[i], mu_r = mu_r, m = 100)$MLE_set$V1, na.rm = TRUE)
}
bias <- matrix(bias, nrow = 3, ncol = 1)
st_d <- matrix(st_d, nrow = 3, ncol = 1)
answers <- cbind(bias, st_d)
answers <- as.data.frame(answers)
colnames(answers) <- c("Bias", "SD")
rownames(answers) <- c("100", "200", "400")
return(list(answers, bias, st_d))
}
#Interval Censored answer function
IC_give_answers <- function(mu_r){
bias <- NULL
st_d <- NULL
sizes <- c(100, 200, 400)
for(i in 1:3){
bias[i] <- mean(cens_sim(1000, n = sizes[i], mu_r = mu_r, m = 100)$MLE_set$V2, na.rm = TRUE) - 5
st_d[i] <- sd(cens_sim(1000, n = sizes[i], mu_r = mu_r, m = 100)$MLE_set$V2, na.rm = TRUE)
}
bias <- matrix(bias, nrow = 3, ncol = 1)
st_d <- matrix(st_d, nrow = 3, ncol = 1)
answers <- cbind(bias, st_d)
answers <- as.data.frame(answers)
colnames(answers) <- c("Bias", "SD")
rownames(answers) <- c("100", "200", "400")
return(list(answers, bias, st_d))
}
#Right Censored Answers
RC1 <- RC_give_answers(5/9)
RC2 <- RC_give_answers(5)
RC3 <- RC_give_answers(45)
print(c(RC1[1],RC2[1],RC3[1]))
#Interval Censored Answers
IC1 <- IC_give_answers(5/9)
IC2 <- IC_give_answers(5)
IC3 <- IC_give_answers(45)
print(c(IC1[1],IC2[1],IC3[1]))
